<!DOCTYPE html>
<html lang="en">

<!-- head -->
<head>
	<base target="_top">
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
	<title>ReTtiCh</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="https://raw.githubusercontent.com/ReTtiChDieOrganisation/ReTtiChDasRepo/main/pics/ReTtiChDasBild.png" />

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

	<script src="./frontend/dependencies/leaflet-motion/dist/leaflet.motion.js"></script>
	<script src="./frontend/data/strava/data.js"></script>
	<script src="./frontend/data/strava/stats.json"></script>

	<script type="text/javascript" src="./frontend/data/rettich/icons.js"></script>

	<style>
		html, body {height: 100%; margin: 0;}
		.leaflet-container {float: left; height: 9000px; width: 10000px; max-width: 70%; max-height: 99%;}
		.rightdivision {float: right; padding-right: 3%; padding-top: 0%; height: 9000px; width: 10000px; max-width: 26%; max-height: 30%;}
		.rightdivision2 {float: right; padding-right: 3%; padding-top: 0%; height: 900px; width: 10000px; max-width: 26%; max-height: 48%;}
		#pauseButton {position: relative; top: 2%; right: 11%; padding: 10px; z-index: 400;}
		#pauseButton:hover {opacity: 0.8; cursor: pointer;}	
		#resumeButton {position: relative; top: 2%; right: 11%; padding: 10px; z-index: 400;}
		#resumeButton:hover {opacity: 0.8; cursor: pointer;}	
		#restartButton {position: relative; top: 2%; right: 11%; padding: 10px; z-index: 400;}
		#restartButton:hover {opacity: 0.8; cursor: pointer;}	
		#speedupButton {position: relative; top: 7%; right: 16%; padding: 10px; z-index: 400;}
		#speedupButton:hover { opacity: 0.8;	cursor: pointer;}
		#slowdownButton {position: relative; top: 7%; right: 16%; padding: 10px; z-index: 400;}
		#slowdownButton:hover {opacity: 0.8; cursor: pointer;}
	</style>
</head>

<!-- body -->
<body>
	<!-- map -->
	<div id="map">
		<script>
			const map = L.map('map').setView([50.896537, 7.025585], 12);
			const tiles = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
				{attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community', maxZoom:21}
			).addTo(map);
			ALL_STATS = JSON.parse(ALL_STATS)
			console.log(ALL_STATS)
			ALL_RIDES = JSON.parse(ALL_RIDES)



			// TODO This should be loaded from ./data/riders.json if we properly know how to
			RIDERS = {
				"Felix": {
					"refresh_token": "0ZPV1KDCo9WkxdTU1pjX1amSqaSpxdXWo5nX1aCXqKPTk9nY1ZnZpQ", 
					"icon_url": "./frontend/piqs/felix_icon.png"
				}, 
				"Philipp": {
					"refresh_token": "08em16GT2dapltaqoZKno6nHo6zWl9mq1JGjqabDo6fVltjUpZmorA", 
					"icon_url": "./frontend/piqs/philipp_icon.png"
				}, 
				"Flo": {
					"refresh_token": "oJXU2NbEqqbVwtfZpsfZ16fGqabTkdejpZWno6SUp6fRxqympMWnqw", 
					"icon_url": "./frontend/piqs/flo_icon.png"
				}, 
				"David": {
					"refresh_token": "05Os2daW1KSlxtTZ0ZemqtOSp6PTl9esppLZ1qDFpKajxdak1pespA", 
					"icon_url": ""
				}, 
				"Lu": {
					"refresh_token": "0ZOm1qSTqtbWxqvUoJOkqNaRo6jRl6yk0ZTZpqKS19WiwqOrqZGlpw", 
					"icon_url": "./frontend/piqs/lu_icon.png"
				}
			}

			
			let NAMES = Object.keys(RIDERS)
			
			class Rettich_rider {
				// constructor
				constructor(name, ride_ids, profile_picture=rettich_profile_pictures.default, frame=rettich_frames.default) {
					// all data members of rettich riders
					this.name = name;
					this.ride_ids = ride_ids;
					this.profile_picture = profile_picture;
					this.frame = frame;
				}

				// getter functions
				get_name () {return this.name;}
				get_ride_ids () {return this.ride_ids;}
				get_profile_picture () {return this.profile_picture;}
				get_frame () {return this.frame;}
				
				// setter functions
				set_name (new_name) {this.name = new_name;}
				set_ride_ids (new_ride_ids) {this.ride_ids = new_ride_ids;}
				set_profile_picture (new_profile_picture) {this.profile_picture = new_profile_picture;}
				set_frame (new_frame) {this.frame = new_frame;}
				set_frame_fg (new_foreground) {this.frame.frame_fg = new_foreground;}
				set_frame_bg (new_background) {this.frame.frame_bg = new_background;}
				set_frame_line_color (new_line_color) {this.frame.line_color = new_line_color;}
			}

			let RIDER_ARR = []
			let ride_ids = []
			
			let id_counter = 0;
			for (name of NAMES){
				//calculate all ids corresponding to this rider
				ride_ids = []
				for (ride_i of Object.keys(ALL_RIDES)){
					if (ALL_RIDES[ride_i].rider==name){
						ride_ids.push(ride_i)
						ALL_RIDES[ride_i]['rider_id'] = id_counter
					}
				}
				rr = new Rettich_rider(name, ride_ids, rettich_profile_pictures[name.toLowerCase()])

				// if (RIDERS[name]['icon_url']==''){
					
				// }
				
				RIDER_ARR.push(rr)
				id_counter +=1
			}
			console.log(ALL_RIDES)




			// ############################################################################################################################
			// initialize all riders data and collect them in one array - this is all the data we need 
			//let felix = new Rettich_rider("felix", (JSON.parse(felix_json)), rettich_profile_pictures.felix, rettich_frames.cinelli);
			//let flo = new Rettich_rider("flo", (JSON.parse(flo_json)), rettich_profile_pictures.flo, rettich_frames.speedster);
			//let philipp = new Rettich_rider("philipp", (JSON.parse(philipp_json)), rettich_profile_pictures.philipp, rettich_frames.orbea);
			//let rettich_all_riders_arr = [philipp, felix, flo]; // TODO: order of riders matters, see rettich_motion_draw_segment()
			//let num_riders = rettich_all_riders_arr.length;
			// ############################################################################################################################

			
			// find group of all rides
			let group_id_all = -1
			let largest_group = -1
			for (group_id_i of Object.keys(ALL_STATS)){
				if (ALL_STATS[group_id_i].ride_ids.length>largest_group){
					largest_group = ALL_STATS[group_id_i].ride_ids.length
					group_id_all = group_id_i
				}
				
			} 

			CURRENT_GROUP = group_id_all;
			CURRENT_GROUP = 8;
			seqGroups = rettich_motion_draw_groups()
			map.on('click', rettich_onMapClick);

			//--------------- only script function definition below ---------------//
			function rettich_motion_draw_groups(lat_lng_startidx_arr=-1,lat_lng_endidx=-1) {
				// draw all_all starting with the corresponding index. So index_set should be an array of indices with the same size as the group corresponding to CURRENT_GROUP


				num_rides = ALL_STATS[CURRENT_GROUP].ride_ids.length
				let lat_lngs_rides_arr = [];
				let speed_set = Array(num_rides).fill(0)
				if (lat_lng_startidx_arr==-1){
					lat_lng_startidx_arr= Array(num_rides).fill(0)
				}
				
				for (const [ride_iterator,ride_id] of  ALL_STATS[CURRENT_GROUP].ride_ids.entries()) {
					current_ride_data = ALL_RIDES[ride_id];


					if (lat_lng_endidx==-1) {
						sliced_latlng = current_ride_data.latlng.data.slice(lat_lng_startidx_arr[ride_iterator]);
						et = current_ride_data.time.data.at(-1)-current_ride_data.time.data[lat_lng_startidx_arr[ride_iterator]];
						dist = current_ride_data.distance.data.at(-1)-current_ride_data.distance.data[lat_lng_startidx_arr[ride_iterator]];
						speed_set[ride_iterator] = 3.6*dist/et;
					}
					else {
						sliced_latlng = current_ride_data.latlng.data.slice(lat_lng_startidx_arr[ride_iterator], lat_lng_endidx[ride_iterator]);
						et = current_ride_data.time.data[lat_lng_endidx[ride_iterator]]-current_ride_data.time.data[lat_lng_startidx_arr[ride_iterator]];
						dist = current_ride_data.distance.data[lat_lng_endidx[ride_iterator]]-current_ride_data.distance.data[lat_lng_startidx_arr[ride_iterator]];
						speed_set[ride_iterator] = 3.6*dist/et;
					}

					lat_lngs_rides_arr.push(sliced_latlng.map(([lat, lng]) => ({ lat, lng })));
				}
			
				seqGroups = []
			
				for (const [ride_iterator,ride_id] of ALL_STATS[CURRENT_GROUP].ride_ids.entries()) {

					current_rider = RIDER_ARR[ALL_RIDES[ride_id]['rider_id']];
					current_ride_lat_lngs = lat_lngs_rides_arr[ride_iterator];
					// frame background
					let poly_frame_fg = L.motion.polyline(
						current_ride_lat_lngs, {
						color: current_rider.get_frame().line_color}, {}, {
						icon: L.icon({
							iconUrl: current_rider.get_frame().frame_fg,
							iconAnchor: current_rider.get_frame().anchor, 
							iconSize: current_rider.get_frame().size}
						)}
					)
			
					// profile picture
					let poly_profile_pic = L.motion.polyline(
						current_ride_lat_lngs, {
						color: current_rider.get_frame().line_color}, {}, {
						icon: L.icon({
							iconUrl: current_rider.get_profile_picture().picture,
							iconAnchor: current_rider.get_profile_picture().anchor, 
							iconSize: current_rider.get_profile_picture().size}
						)}
					)

					//frame foreground
					let poly_frame_bg = L.motion.polyline(
						current_ride_lat_lngs, {
						color: current_rider.get_frame().line_color}, {}, {
						icon: L.icon({
							iconUrl: current_rider.get_frame().frame_bg,
							iconAnchor: current_rider.get_frame().anchor, 
							iconSize: current_rider.get_frame().size}
						)}
					)
			
					if (speed_set!=-1) {
						poly_frame_bg.motionSpeed(speed_set[ride_iterator]);
						poly_profile_pic.motionSpeed(speed_set[ride_iterator]);
						poly_frame_fg.motionSpeed(speed_set[ride_iterator]);
					}

					seqGroups.push(L.motion.seq([poly_frame_bg]).addTo(map));
					seqGroups.push(L.motion.seq([poly_profile_pic]).addTo(map));
					seqGroups.push(L.motion.seq([poly_frame_fg]).addTo(map));
				}

				for (seqGroup of seqGroups){
					seqGroup.motionStart();
				}

				return seqGroups
			}
			
			function rettich_get_distance(p,q) {
				return Math.sqrt(Math.pow(p[0] - q[0], 2) + Math.pow(p[1] - q[1], 2))
			}
			
			function rettich_find_closest_index(arrayOP, point){
				// Calculates the index of the array of points for the closest to point, last index not checked
				let dist = 99999999.0; // just some random - for planet earth - high enough value
				let idx = -1;
			
				for (i = 0; i < arrayOP.length-1; i++){
					point_i = arrayOP[i];
					dist_i = rettich_get_distance(point_i,point)
					if (dist_i<dist){
						dist = dist_i;
						idx = i;
					}
				}
				return idx
			}
			
			function rettich_onMapClick(e) {
				lat_lng_startidx_arr = [];
				if (typeof ALL_STATS=='string'){
					ALL_STATS = JSON.parse(ALL_STATS) // i have no idea why i have to parse it here again
				}
				
				for (const [ride_iterator,ride_id] of  ALL_STATS[CURRENT_GROUP]['ride_ids'].entries()) {
					current_ride_data = ALL_RIDES[ride_id];
					idx_temp = rettich_find_closest_index(current_ride_data.latlng.data,[e.latlng.lat, e.latlng.lng]);
					lat_lng_startidx_arr.push(idx_temp);
				}
					
				
				rettich_remove_all_rides_from_map()
				seqGroups = rettich_motion_draw_groups(lat_lng_startidx_arr)
			}
			
			function rettich_remove_all_rides_from_map() { 
				for (seqGroup of seqGroups){
					seqGroup.motionStop();
					seqGroup.removeFrom(map);
				}
			
				if (typeof marker_start !== 'undefined'){
					map.removeLayer(marker_start);
				}
			
				if (typeof marker_finish !== 'undefined'){
					map.removeLayer(marker_finish);
				}
			}
			
			function rettich_motion_keys(key) {
				for (seqGroup of seqGroups){
					if (key == "stop"){
						seqGroup.motionStop();
					}else if (key == "pause"){
						seqGroup.motionPause();
					}else if (key == "resume"){
						seqGroup.motionResume();
					}else if (key == "toggle"){
						seqGroup.motionToggle();
					}else if (key == "restart"){
						rettich_remove_all_rides_from_map()
						current_segment = $("#sel").val().split(',')
						if (current_segment == ""){
							rettich_motion_draw_groups()
						}else{
							rettich_motion_draw_segment(current_segment[0])
						}
					}else if (key == "speedup"){
						seqGroup.getFirstLayer().motionSpeed(seqGroup.getFirstLayer().motionOptions.speed*2);
					}else if (key == "slowdown"){
						seqGroup.getFirstLayer().motionSpeed(seqGroup.getFirstLayer().motionOptions.speed*0.5);
					}
				}
			}		
		</script>
	</div>

	<!-- buttons auf map -->
	<button id="pauseButton" onClick="rettich_motion_keys('pause')">Pause</button>
	<button id="resumeButton" onClick="rettich_motion_keys('resume')">Resume</button>
	<button id="restartButton" onClick="rettich_motion_keys('restart')">Restart</button>
	<button id="speedupButton" onClick="rettich_motion_keys('speedup')">2x</button>
	<button id="slowdownButton" onClick="rettich_motion_keys('slowdown')">0.5x</button>
	
	<!-- medals table -->
	<div class = "rightdivision" id="stats">
		<select id="sel_group" onchange="rettich_getComboGroup(this)">
			<option value="">--Please choose a group--</option>
		</select>


		<canvas id="myChart"></canvas>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="./frontend/data/strava/stats.json"></script>
		<script>
			function rettich_draw_medals(){
				if (typeof ALL_STATS=='string'){
				ALL_STATS = JSON.parse(ALL_STATS) // i still have no idea why i have to parse it here again
			}
			console.log(ALL_STATS)

			const ctx = document.getElementById('myChart');
			
			let medal_labels = ALL_STATS[CURRENT_GROUP]['riders']
			let medal_data_gold = []
			let medal_data_silver = []
			let medal_data_bronze = []
			for (const [ride_iterator, ride_id] of  ALL_STATS[CURRENT_GROUP].ride_ids.entries()) {
					medal_data_gold.push(ALL_STATS[CURRENT_GROUP]['medals'][ride_id][0])
					medal_data_silver.push(ALL_STATS[CURRENT_GROUP]['medals'][ride_id][1])
					medal_data_bronze.push(ALL_STATS[CURRENT_GROUP]['medals'][ride_id][2])
			}
			if (typeof medal_chart !== 'undefined') {
				medal_chart.destroy();
			}
			medal_chart = new Chart(ctx,
			{
				type: 'bar',
				data:
				{
					labels: medal_labels,
					datasets: [
					{
						label: 'Gold',
						data: medal_data_gold,
						borderWidth: 1,
						backgroundColor: "rgb(255,215,0)",
						stack: 'Stack 0',
					},
					{
						label: 'Silver',
						data: medal_data_silver,
						borderWidth: 1,
						backgroundColor: "rgb(208,208,208)",
						stack: 'Stack 1',
					},
					{
						label: 'Bronze',
						data: medal_data_bronze,
						borderWidth: 1,
						backgroundColor: "rgb(205,127,50)",
						stack: 'Stack 2',
					},]
				},
				options:
				{
					scales:
					{
						y: 
						{
							stacked: true,
							beginAtZero: true
						}
					}
				}
			});
			}
			rettich_draw_medals()
		</script>
	</div>

	<!-- choose segment table and adjust map to segment -->
	<div class = "rightdivision2" id="stats">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
		<link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/jquery.dataTables.css" />
		<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.js"></script>	

		<select id="sel" onchange="rettich_getComboA(this)">
			<option value="">--Please choose a segment--</option>
		</select>
		
		<table id="stats_table" class="display" style="width:100%">
			<thead>
				<tr>
					<th>Rider</th>
					<th>Time [min:s]</th>
					<th>Speed [km/h]</th>
					<th>Power [W]</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>Philipp</td>
					<td align="center"></td>
					<td align="center"></td>
					<td align="center"></td>

				</tr>
				<tr>
					<td>Felix</td>
					<td align="center"></td>
					<td align="center"></td>
					<td align="center"></td>
				</tr>
				<tr>
					<td>Flo</td>
					<td align="center"></td>
					<td align="center"></td>
					<td align="center"></td>
				</tr>
			</tbody>
		</table>
		
		<script>
			if (typeof ALL_STATS=='string'){
				ALL_STATS = JSON.parse(ALL_STATS) // i have no idea why i have to parse it here again
			}
			

			let myTable = document.getElementById("stats_table");

			
			$(function() {
			$.each(ALL_STATS, function(i, option) {
				$('#sel_group').append($('<option/>').attr("value", [i]).text(option['riders']));
			});
		})

			//--------------- only script function definition below ---------------//
			function rettich_getComboGroup(selectObject) {
				
				value = selectObject.value; 
				key = selectObject;
				CURRENT_GROUP=value;
				rettich_draw_medals()
				rettich_remove_all_rides_from_map()
				seqGroups = rettich_motion_draw_groups()
				const all_rides_segment_efforts = ALL_STATS[CURRENT_GROUP]['segments'];
				$(function() {
				$.each(all_rides_segment_efforts, function(i, option) {
					abcde = [i]
					for (ride_id of ALL_STATS[CURRENT_GROUP]['ride_ids']){
						abcde.push(option[ride_id].time)
						}
					$('#sel').append($('<option/>').attr("value", abcde).text(i));
				});
			})
			}
			function rettich_getComboA(selectObject) {
				value = selectObject.value; 
				key = selectObject;

				// seperated_values = [seg_name, num_coords_curr_segm_rider1, ... , num_coords_curr_segm_ridern]
				seperated_values = value.split(',');
				segment_name = seperated_values[0];
				for (seqGroup of seqGroups){
					seqGroup.motionStop();
					seqGroup.removeFrom(map);
				
					if (typeof marker_start !== 'undefined'){
						map.removeLayer(marker_start);
					}

					if (typeof marker_finish !== 'undefined'){
						map.removeLayer(marker_finish);
					}
				}
				
				if (seperated_values==""){
					seqGroups = rettich_motion_draw_groups()
					map.setView([50.896537, 7.025585], 12);
				} 
				else {
					let num_rides_at_current_segment = seperated_values.length-1;

					for (let riders_iterator = 1; riders_iterator <= num_rides_at_current_segment; riders_iterator++) {
						myTable.rows[riders_iterator].cells[1].textContent = rettich_fancyTimeFormat(seperated_values[riders_iterator]);
					}

					// myTable.rows[1].cells[2].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Philipp.speed*100)/100;
					// myTable.rows[2].cells[2].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Felix.speed*100)/100;
					// myTable.rows[3].cells[2].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Flo.speed*100)/100;

					// myTable.rows[1].cells[3].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Philipp.power*100)/100;
					// myTable.rows[2].cells[3].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Felix.power*100)/100;
					// myTable.rows[3].cells[3].textContent = Math.round(all_riders_strava_segment_efforts[segment_name].Flo.power*100)/100;
					
					rettich_motion_draw_segment(segment_name)
				}
			}

			function rettich_fancyTimeFormat(duration) {
				// Hours, minutes and seconds
				const hrs = ~~(duration / 3600);
				const mins = ~~((duration % 3600) / 60);
				const secs = ~~duration % 60;

				// Output like "1:01" or "4:03:59" or "123:03:59"
				let ret = "";

				if (hrs > 0) {
					ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
				}

				ret += "" + mins + ":" + (secs < 10 ? "0" : "");
				ret += "" + secs;

				return ret;
			}

			function rettich_motion_draw_segment(seg_name) {
			
				
				start_idx_set = []
				end_idx_set = []
				for (const [ride_iterator,ride_id] of  ALL_STATS[CURRENT_GROUP].ride_ids.entries()) {
					start_idx_set.push(ALL_STATS[CURRENT_GROUP]['segments'][seg_name][ride_id]['start_index'])
					end_idx_set.push(ALL_STATS[CURRENT_GROUP]['segments'][seg_name][ride_id]['end_index'])
				}

				rettich_motion_draw_groups(start_idx_set,end_idx_set)
				marker_start = rettich_static_draw_marker(ALL_STATS[CURRENT_GROUP]['segments'][seg_name]['Segment']['start_latlng'], rettich_other_icons.start)
				marker_finish = rettich_static_draw_marker(ALL_STATS[CURRENT_GROUP]['segments'][seg_name]['Segment']['end_latlng'], rettich_other_icons.finish)
				
				center = rettich_get_segment_center(marker_start, marker_finish)
				bounds = L.latLngBounds(marker_start.getLatLng(), marker_finish.getLatLng())

				map.setView(center);
				map.fitBounds(bounds)
			}

			function rettich_static_draw_marker(latlng, marker_icon) {
				return L.marker(
					latlng, {
					icon: L.icon({
						iconUrl: marker_icon.icon,
						iconAnchor: marker_icon.anchor, 
						iconSize: marker_icon.size})}
				).addTo(map);
			}

			function rettich_get_segment_center(start, finish) {
				coefficient = 1;

				if ((start.getLatLng().lat > 90 && finish.getLatLng().lat < -90) || (finish.getLatLng().lat > 90 && start.getLatLng().lat < -90)) {
					midLat = 180 - ((start.getLatLng().lat - finish.getLatLng().lat) / 2).abs();
					
					// If output will be in the 1st quartile then co-ef will remain 1, if in 4th then it will be -1
					if ((start.getLatLng().lat < 0 && start.getLatLng().lat.abs() < finish.getLatLng().lat.abs()) ||
						(finish.getLatLng().lat < 0 && finish.getLatLng().lat.abs() < start.getLatLng().lat.abs())) {
						coefficient = -1;
					}
					
					// Applying coefficient
					midLat *= coefficient;
				}
				else {
					midLat = (finish.getLatLng().lat + start.getLatLng().lat) / 2;
				}
				
				// Calculating midLong
				coefficient = 1;

				if ((start.getLatLng().lng > 90 && finish.getLatLng().lng < -90) || (finish.getLatLng().lng > 90 && start.getLatLng().lng < -90)) {
					midLong = 180 - ((start.getLatLng().lng.abs() - finish.getLatLng().lng.abs()) / 2).abs();
					
					// If output will be in the 1st quartile then co-ef will remain 1, if in 4th then it will be -1
					if ((start.getLatLng().lng < 0 && start.getLatLng().lng.abs() < finish.getLatLng().lng.abs()) ||
						(finish.getLatLng().lng < 0 && finish.getLatLng().lng.abs() < start.getLatLng().lng.abs())) {
						coefficient = -1;
					}

					// Applying coefficient
					midLong *= coefficient;
				} 
				else {
					midLong = (finish.getLatLng().lng + start.getLatLng().lng) / 2;
				}

				return [midLat, midLong]
			}
		</script>
	</div>
</body>
</html>
